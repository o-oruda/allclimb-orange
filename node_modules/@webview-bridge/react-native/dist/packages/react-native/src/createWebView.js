"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createWebView = void 0;
const util_1 = require("../../../shared/util/src");
const react_1 = __importStar(require("react"));
const react_native_webview_1 = __importDefault(require("react-native-webview"));
const bridge_1 = require("./integrations/bridge");
const console_1 = require("./integrations/console");
const handleRegisterWebMethod_1 = require("./integrations/handleRegisterWebMethod");
/**
 * Create a WebView component that can communicate with the bridge.
 * @link https://gronxb.github.io/webview-bridge/getting-started.html
 * @example
    import { createWebView, bridge } from "@webview-bridge/react-native";
    import InAppBrowser from "react-native-inappbrowser-reborn";

    // Register functions in the bridge object in your React Native code
    export const appBridge = bridge({
      async getMessage() {
        return "Hello, I'm native";
      },
      async sum(a: number, b: number) {
        return a + b;
      },
      async openInAppBrowser(url: string) {
        if (await InAppBrowser.isAvailable()) {
          await InAppBrowser.open(url);
        }
      },
      // ... Add more functions as needed
    });

    export const { WebView } = createWebView({
      bridge: appBridge,
      debug: true, // Enable console.log visibility in the native WebView
    });
 */
const createWebView = ({ bridge, debug, responseTimeout = 2000, postMessageSchema, fallback, }) => {
    const WebMethod = {
        current: {
            isReady: false,
        },
    };
    const webviewRefList = [];
    const emitter = (0, util_1.createEvents)();
    bridge.subscribe((state) => {
        for (const ref of webviewRefList) {
            ref?.current?.injectJavaScript((0, bridge_1.SAFE_NATIVE_EMITTER_EMIT)("bridgeStateChange", state));
        }
    });
    return {
        /**
         * Sends an event from React Native to the Web.
         * @link https://gronxb.github.io/webview-bridge/using-a-post-message.html
         */
        postMessage: (eventName, args) => {
            let _args = args;
            if (postMessageSchema) {
                _args = postMessageSchema[eventName].parse(args);
            }
            for (const ref of webviewRefList) {
                ref?.current?.injectJavaScript((0, bridge_1.SAFE_NATIVE_EMITTER_EMIT)(`postMessage/${String(eventName)}`, _args));
            }
        },
        WebView: (0, react_1.forwardRef)((props, ref) => {
            const webviewRef = (0, react_1.useRef)(null);
            (0, react_1.useLayoutEffect)(() => {
                webviewRefList.push(webviewRef);
                return () => {
                    webviewRefList.pop();
                };
            }, []);
            const initData = (0, react_1.useMemo)(() => {
                const bridgeMethods = Object.entries(bridge.getState() ?? {})
                    .filter(([_, bridge]) => typeof bridge === "function")
                    .map(([name]) => name);
                const initialState = Object.fromEntries(Object.entries(bridge.getState() ?? {}).filter(([_, value]) => typeof value !== "function"));
                return { bridgeMethods, initialState };
            }, []);
            (0, react_1.useEffect)(() => {
                webviewRef.current?.injectJavaScript((0, bridge_1.SAFE_NATIVE_EMITTER_EMIT)("hydrate", initData));
            }, [initData]);
            (0, react_1.useImperativeHandle)(ref, () => webviewRef.current, []);
            const handleMessage = async (event) => {
                props.onMessage?.(event);
                if (!webviewRef.current) {
                    return;
                }
                const { type, body } = JSON.parse(event.nativeEvent.data);
                switch (type) {
                    case "log": {
                        const { method, args } = body;
                        debug && (0, console_1.handleLog)(method, args);
                        return;
                    }
                    case "bridge": {
                        const { method, args, eventId } = body;
                        (0, bridge_1.handleBridge)({
                            bridge,
                            method,
                            args,
                            eventId,
                            webview: webviewRef.current,
                        });
                        return;
                    }
                    case "getBridgeState": {
                        for (const ref of webviewRefList) {
                            ref?.current?.injectJavaScript((0, bridge_1.SAFE_NATIVE_EMITTER_EMIT)("bridgeStateChange", bridge.getState()));
                        }
                        return;
                    }
                    case "registerWebMethod": {
                        const { bridgeNames } = body;
                        Object.assign(WebMethod.current, (0, handleRegisterWebMethod_1.handleRegisterWebMethod)(emitter, webviewRef.current, bridgeNames, responseTimeout));
                        WebMethod.current.isReady = true;
                        return;
                    }
                    case "webMethodResponse": {
                        const { eventId, funcName, value } = body;
                        emitter.emit(`${funcName}-${eventId}`, value);
                        return;
                    }
                    case "webMethodError": {
                        const { eventId, funcName } = body;
                        emitter.emit(`${funcName}-${eventId}`, {}, true);
                        return;
                    }
                    case "fallback": {
                        const { method } = body;
                        fallback?.(method);
                        return;
                    }
                }
            };
            return (<react_native_webview_1.default {...props} ref={webviewRef} onMessage={handleMessage} injectedJavaScriptBeforeContentLoaded={[
                    (0, bridge_1.INJECT_BRIDGE_METHODS)(initData.bridgeMethods),
                    (0, bridge_1.INJECT_BRIDGE_STATE)(initData.initialState),
                    props.injectedJavaScriptBeforeContentLoaded,
                    "true;",
                ]
                    .filter(Boolean)
                    .join("\n")} injectedJavaScript={[
                    debug && console_1.INJECT_DEBUG,
                    props.injectedJavaScript,
                    "true;",
                ]
                    .filter(Boolean)
                    .join("\n")}/>);
        }),
        /**
         * @deprecated Use `postMessage` instead.  And complete the type through the `postMessageSchema` option.
         * @see https://gronxb.github.io/webview-bridge/using-a-post-message.html
         * @example
          import { createWebView, postMessageSchema } from "@webview-bridge/react-native";
          import { z } from "zod";
    
          const appPostMessageSchema = postMessageSchema({
            eventName1: z.object({
              message: z.string(),
            }),
            eventName2: z.string(),
          });
    
    
          // Export the event schema to be used in the web application
          export type AppPostMessageSchema = typeof appPostMessageSchema;
    
          // When you bridge a webview, a postMessage is extracted.
          export const { postMessage } = createWebView({
            postMessageSchema: appPostMessageSchema, // Pass in the your schema. This is optional, so if the type doesn't matter to you, you don't need to include it.
            // ..
          });
    
          // usage
          postMessage("eventName1", {
            message: "test",
          });
          postMessage("eventName2", "test");
        */
        linkWebMethod() {
            return WebMethod;
        },
    };
};
exports.createWebView = createWebView;
