import type { Bridge, BridgeStore, KeyOfOrString, Parser, ParserSchema } from "../../../shared/util/src/types";
import React from "react";
import type { BridgeWebView } from "./types/webview";
export type CreateWebViewArgs<BridgeObject extends Bridge, PostMessageSchema extends ParserSchema<any>> = {
    /**
     * The bridge object to be used in the WebView.
    * @example
      import { createWebView, bridge } from "@webview-bridge/react-native";
      import InAppBrowser from "react-native-inappbrowser-reborn";
  
      // Register functions in the bridge object in your React Native code
      export const appBridge = bridge({
        async getMessage() {
          return "Hello, I'm native";
        },
        async sum(a: number, b: number) {
          return a + b;
        },
        async openInAppBrowser(url: string) {
          if (await InAppBrowser.isAvailable()) {
            await InAppBrowser.open(url);
          }
        },
        // ... Add more functions as needed
      });
  
      export const { WebView } = createWebView({
        bridge: appBridge,
        debug: true, // Enable console.log visibility in the native WebView
      });
      */
    bridge: BridgeStore<BridgeObject>;
    /**
     * If `true`, the console.log visibility in the WebView is enabled.
     * @default false
     */
    debug?: boolean;
    /**
     * Set the timeout in milliseconds for the response from the web method.
     * @default 2000
     */
    responseTimeout?: number;
    /**
     * The schema for the postMessage method.
     * @link https://gronxb.github.io/webview-bridge/using-a-post-message.html
     */
    postMessageSchema?: PostMessageSchema;
    /**
     * Callback function when a method that is not defined in the bridge is called.
     * @link https://gronxb.github.io/webview-bridge/backward-compatibility/new-method.html#react-native-part
     */
    fallback?: (method: keyof BridgeObject) => void;
};
export type WebMethod<T> = T & {
    isReady: boolean;
};
/**
 * Create a WebView component that can communicate with the bridge.
 * @link https://gronxb.github.io/webview-bridge/getting-started.html
 * @example
    import { createWebView, bridge } from "@webview-bridge/react-native";
    import InAppBrowser from "react-native-inappbrowser-reborn";

    // Register functions in the bridge object in your React Native code
    export const appBridge = bridge({
      async getMessage() {
        return "Hello, I'm native";
      },
      async sum(a: number, b: number) {
        return a + b;
      },
      async openInAppBrowser(url: string) {
        if (await InAppBrowser.isAvailable()) {
          await InAppBrowser.open(url);
        }
      },
      // ... Add more functions as needed
    });

    export const { WebView } = createWebView({
      bridge: appBridge,
      debug: true, // Enable console.log visibility in the native WebView
    });
 */
export declare const createWebView: <BridgeObject extends Bridge, PostMessageSchema extends ParserSchema<any>>({ bridge, debug, responseTimeout, postMessageSchema, fallback, }: CreateWebViewArgs<BridgeObject, PostMessageSchema>) => {
    /**
     * Sends an event from React Native to the Web.
     * @link https://gronxb.github.io/webview-bridge/using-a-post-message.html
     */
    postMessage: <EventName extends KeyOfOrString<PostMessageSchema>, Args extends Parser<PostMessageSchema, EventName>>(eventName: EventName, args: Args) => void;
    WebView: React.ForwardRefExoticComponent<import("react-native-webview/lib/WebViewTypes").IOSWebViewProps & import("react-native-webview/lib/WebViewTypes").AndroidWebViewProps & import("react-native-webview/lib/WebViewTypes").WindowsWebViewProps & React.RefAttributes<BridgeWebView>>;
    /**
     * @deprecated Use `postMessage` instead.  And complete the type through the `postMessageSchema` option.
     * @see https://gronxb.github.io/webview-bridge/using-a-post-message.html
     * @example
      import { createWebView, postMessageSchema } from "@webview-bridge/react-native";
      import { z } from "zod";

      const appPostMessageSchema = postMessageSchema({
        eventName1: z.object({
          message: z.string(),
        }),
        eventName2: z.string(),
      });


      // Export the event schema to be used in the web application
      export type AppPostMessageSchema = typeof appPostMessageSchema;

      // When you bridge a webview, a postMessage is extracted.
      export const { postMessage } = createWebView({
        postMessageSchema: appPostMessageSchema, // Pass in the your schema. This is optional, so if the type doesn't matter to you, you don't need to include it.
        // ..
      });

      // usage
      postMessage("eventName1", {
        message: "test",
      });
      postMessage("eventName2", "test");
    */
    linkWebMethod<T>(): {
        current: WebMethod<T>;
    };
};
